## 1.说说对 HTML 语义化的理解

我理解的语义化，就是在正确的地方用正确的html标签，是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。

常用的语义化标签如下：

```html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

语义化的优点：

- 在没有CSS样式情况下也能够让页面呈现出清晰的结构；
- 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
- 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

## 2.块级元素和行内元素的特点，如何转换？

块级元素和行内元素都是对标签的分类，核心区别就是如何占据页面。

常用的块级元素和行内元素如下：

```html
// 块级元素
<div>、<p>、<h1>~<h6>、<ul>、<ol>、<li>、<form>、<header>、<footer>、<main>
// 行内元素
<a>、<span>、<img>、<input>、<label>、<select>、<textarea>、<button>、<br>、<i>、<em>、<strong>
```

块级元素特点：

- 总是在新行上开始，既每个块级元素独占一行，默认从上到下排列。
- 默认宽度是父级元素的百分之百，可以独立设置宽度。
- 高度，行高，及其margin和padding都是可以手动设置的。
- 块级元素可以容纳其他行级元素和块级元素。

行内元素特点：

- 和其他元素会在一行显示，直到宽度不足才会挤到下一行去显示。
- 高度和宽度无法通过width和height设置。
- margin和height设置左右有效，上下无效
- 行内元素只能补充文本或行内元素

补充：行内块元素：

- 不独占一行，但是可以设置宽高之类，相当于，只有行内的一个特点，其他的特点都是块的特点。

## 3.HTML5 有哪些新元素和新特性？

1. 语义化标签的添加，看1。

2. 新的媒体标签

   1. audio：音频

      ```html
      <audio src='' controls autoplay loop='true'></audio>
      controls 控制面板
      autoplay 自动播放
      loop=‘true’ 循环播放
      ```

   2. video视频

      ```html
      <video src='' poster='imgs/aa.jpg' controls></video>
      poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。
      controls 控制面板
      width
      height
      ```

   3. source标签 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。

      ```html
      <video>
       	<source src='aa.flv' type='video/flv'></source>
       	<source src='aa.mp4' type='video/mp4'></source>
      </video>
      ```

3. 表单

   1. **表单类型：**
      - email ：能够验证当前输入的邮箱地址是否合法
      - url ： 验证URL
      - number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。
      - search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。
      - range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值
      - color ： 提供了一个颜色拾取器
      - time ： 时分秒
      - data ： 日期选择年月日
      - datatime ： 时间和日期(目前只有Safari支持)
      - datatime-local ：日期时间控件
      - week ：周控件
      - month：月控件
   2. **表单属性：**
      - placeholder ：提示信息
      - autofocus ：自动获取焦点
      - autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：
        - 表单必须提交过
        - 必须有name属性。
      - required：要求输入框不能为空，必须有值才能够提交。
      - pattern=" " 里面写入想要的正则模式，例如手机号patte="^(+86)?\d{10}$"
      - multiple：可以选择多个文件或者多个邮箱
      - form=" form表单的ID"
   3. **表单事件：**
      - oninput 每当input里的输入框内容发生变化都会触发此事件。
      - oninvalid 当验证不通过时触发此事件。

4.  进度条、度量器

5. DOM查询操作

   - document.querySelector()
   - document.querySelectorAll()

6. Web存储

   - localStorage - 没有时间限制的数据存储
   - sessionStorage - 针对一个 session 的数据存储

7. canvas和svg，拖放

## 4.DOCTYPE 的作用是什么？

`Doctype`是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为`怪异模式`，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的`bug`，所以文档声明是必须的。

1. **CSS1Compat：标准模式（Strick mode）**，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
2. **BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。

## 5.src 和 href 的区别

src和href都是**用来引用外部的资源**，它们的区别如下：

- **src：** 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
- **href：** 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。

## 6.常⽤的meta标签有哪些（viewport）

`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些`name`作为大家使用的共识，开发者还可以自定义name。<meta>标签的用途是提供关于 HTML 文档的元数据。元数据指的是那些不会在网页上直接显示，却能为浏览器（比如如何显示内容或者刷新页面）、搜索引擎（像 SEO 相关信息）以及其他网络服务提供指引的数据。常用的meta标签： 

（1）`charset`，用来描述HTML文档的编码类型：

```html
<meta charset="UTF-8" >
```

（2） `keywords`，页面关键词：

```html
<meta name="keywords" content="关键词" />
```

（3）`description`，页面描述：

```html
<meta name="description" content="页面描述内容" />
```

（4）`refresh`，页面重定向和刷新：

```html
<meta http-equiv="refresh" content="0;url=" />
```

（5）`viewport`，适配移动端，可以控制视口的大小和比例：

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
```

其中，`content` 参数有以下几种：

- `width viewport` ：宽度(数值/device-width)
- `height viewport` ：高度(数值/device-height)
- `initial-scale` ：初始缩放比例
- `maximum-scale` ：最大缩放比例
- `minimum-scale` ：最小缩放比例
- `user-scalable` ：是否允许用户缩放(yes/no）

（6）搜索引擎索引方式：

```html
<meta name="robots" content="index,follow" />
```

其中，`content` 参数有以下几种：

- `all`：文件将被检索，且页面上的链接可以被查询；
- `none`：文件将不被检索，且页面上的链接不可以被查询；
- `index`：文件将被检索；
- `follow`：页面上的链接可以被查询；
- `noindex`：文件将不被检索；
- `nofollow`：页面上的链接不可以被查询。

## 7.前端页面的三层结构

**结构层（structural layer）：HTML**

结构层类似于盖房子需要打地基以及房子的悬梁框架，它是由HTML超文本标记语言来创建的，也就是页面中的各种标签，在结构层中保存了用户可以看到的所有内容，比如说：一段文字、一张图片、一段视频等等

**表示层（presentation layer）：CSS**

表示层是由CSS负责创建，它的作用是如何显示有关内容，学名：`层叠样式表`，也就相当于装修房子，看你要什么风格的，田园的、中式的、地中海的，总之CSS都能办妥

**行为层（behaviorlayer）：JavaScript**

行为层表示网页内容跟用户之间产生交互性，简单来说就是用户操作了网页，网页给用户一个反馈，这是`JavaScript`和`DOM`主宰的领域

三层结构的优势：

- **可维护性**：各层分工明确，修改样式或交互逻辑时，不会对网页结构造成影响。
- **可扩展性**：能够独立对某一层进行扩展，比如添加新的样式或者交互功能。
- **可访问性**：合理的 HTML 结构有助于屏幕阅读器等辅助设备理解网页内容，方便残障人士使用。
- **性能优化**：可以针对各层分别进行性能优化，例如压缩 CSS、懒加载 JavaScript 等。

## 8.Canvas 和 SVG 的区别

**SVG：** SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

其特点如下：

- 不依赖分辨率
- 支持事件处理器
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
- 不适合游戏应用

**Canvas：** Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。

其特点如下：

- 依赖分辨率
- 不支持事件处理器
- 弱的文本渲染能力
- 能够以 .png 或 .jpg 格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。

## 9.iframe 的优缺点

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

**优点：**

1. 用来加载速度较慢的内容（如广告）。
2. 可以在页面上独立显示一个页面或者内容,不会与页面其他元素产生冲突。
3. 加载是异步的,页面可以在不等待 iframe 加载完成的情况下进行展示。
4. 方便地实现跨域访问。
5. 可以使脚本可以并行下载
6. 可以实现跨子域通信

**缺点：**

1. iframe 会阻塞主页面的 onload 事件。
2. 无法被一些搜索引擎索识别。
3. 会产生很多页面，不容易管理。
4. 和主页面共享连接池,影响页面并行加载。

## 10.Web Worker 的作用

`Web Worker` 是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。

因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。

## 11.渐进增强和优雅降级的区别

**（1）渐进增强（progressive enhancement）**：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 **（2）优雅降级 graceful degradation**： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

**两者区别：**

- 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
- 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。

“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。

“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。

## 12.HTML5 离线存储原理

离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

**原理：**HTML5的离线存储是基于一个新建的 `.appcache` 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

**使用方法：**

1. 创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：

   ```html
   <html lang="en" manifest="index.manifest">
   ```

2. 在 `cache.manifest` 文件中编写需要离线存储的资源：

   ```html
   CACHE MANIFEST
       #v0.11
       CACHE:
       js/app.js
       css/style.css
       NETWORK:
       resourse/logo.png
       FALLBACK:
       / /offline.html
   ```

   **CACHE**: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。

   **NETWORK**: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。

   **FALLBACK**: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。

3. 在离线状态时，操作 `window.applicationCache` 进行离线缓存的操作。

**如何更新缓存：**

（1）更新 manifest 文件

（2）通过 javascript 操作

（3）清除浏览器缓存

**注意事项：**

（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。

（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。

（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。

（4）FALLBACK 中的资源必须和 manifest 文件同源。

（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。

（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。

（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。

**在线的情况下**，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。

**离线的情况下**，浏览器会直接使用离线存储的资源。

## 13.srcset 属性的作用

响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：

```html
<img src="image-128.png" srcset="image-256.png 2x" />
```

使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。

按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：

```html
<img src="image-128.png"
     srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
     sizes="(max-width: 360px) 340px, 128px" />
```

其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。

sizes语法如下：

```html
sizes="[media query] [length], [media query] [length] ... "
```

sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。

## 14.浏览器乱码的原因及解决方法

**产生乱码的原因：**

- 网页源代码是`gbk`的编码，而内容中的中文字是`utf-8`编码的，这样浏览器打开即会出现`html`乱码，反之也会出现乱码；
- `html`网页编码是`gbk`，而程序从数据库中调出呈现是`utf-8`编码的内容也会造成编码乱码；
- 浏览器不能自动检测网页编码，造成网页乱码。

**解决办法：**

- 使用软件编辑HTML网页内容；
- 如果网页设置编码是`gbk`，而数据库储存数据编码格式是`UTF-8`，此时需要程序查询数据库数据显示数据前进程序转码；
- 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。

## 15.HTML5 拖放 API（Drag & Drop）

dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。

darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。

dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。

dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。

dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。

drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。

dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。

## 16.Web Components 的理解

Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。Web Components 也是一个浏览器原生支持的组件化方案，允许你创建新的自定义、可封装的HTML 标记，使用时不用加载任何额外的模块。自定义组件和小部件基于 Web Components 标准构建，可跨现代浏览器工作，并可与任何支持 HTML 的 JavaScript 库或框架一起使用。

其实简单理解 Web Components 就是：**Web Components 是一套技术，允许创建可重用的自定义元素**

而 Web Component 的目的也很明确，从`原生层面实现组件化，使开发者开发、复用、扩展自定义组，实现自定义标签`。意味着前端开发人员开发组件时可以实现 `Write once, run anywhere`。

## 17.如何优化 HTML 性能？

HTML 性能优化的核心策略：

1. **减少请求**：合并、压缩、内联资源。
2. **优化加载顺序**：优先加载关键资源，懒加载非关键内容。
3. **缓存利用**：合理设置缓存头，使用 Service Workers。
4. **资源优化**：使用高效图片格式，压缩文件大小。
5. **结构优化**：语义化标签，减少 DOM 复杂度。

## 18.SEO 友好的 HTML 结构设计

SEO 友好的 HTML 结构核心原则：

1. **语义化**：使用正确的 HTML5 标签表达内容结构。
2. **关键词优化**：自然分布关键词，重点关注标题和元标签。
3. **用户体验**：优化加载速度、导航和移动友好性。
4. **技术合规**：避免黑帽技术，确保内容可被爬虫访问。

## 19.`<template>`标签的作用

`<template>` 是 HTML5 引入的一个特殊标签，用于定义页面中暂时不渲染的 HTML 内容模板。这些模板可以在运行时通过 JavaScript 动态实例化并插入到 DOM 中，是构建动态 Web 应用的重要工具。

### **核心作用**

1. **定义可复用的 HTML 结构**
   `<template>` 内的内容不会被浏览器直接渲染，而是作为 “蓝图” 存储，可在需要时克隆使用。
2. **保持 DOM 整洁**
   避免在初始渲染时包含大量隐藏内容，减少首屏加载时间。
3. **与 JavaScript 结合实现动态 UI**
   通过 JS 操作模板内容，高效生成复杂的 DOM 结构。

## 20.HTML 实体编码的作用

HTML 实体编码是处理特殊字符的标准方法，主要用于：

- 安全显示 HTML 保留字符。
- 呈现无法直接输入的符号。
- 防止 XSS 攻击。
- 确保跨平台和浏览器的一致性显示。